In distributed systems, data is partitioned and stored in storage devices (nodes) that are separated from each others in location. For example, in a small scale distributed system, a file could be stored in multiple hard disks. In a large system, data segments could be stored in different data centers located in separate geographical locations. When a particular data is being accessed by an user, the system resembles data from partitions and response to the request. From the user's perspective, read and write access to a distributed file should be no different from accessing a local file.

Two of the most important considerations when designing distributed storage system is performance and redundancy. The former refers to I/O speed and latency user may experience. It is subjected to system architecture design and quality of hardware and communication channels. Data redundancy provides backup to data to lower the probability of error during data access due to system faults. Noted that there exists another type of error where data being tempered in storage or transmission. Detecting and correcting such error is another complicated problem in the domain digital communication, where is not in the scope of this paper.
Individual disk failure is a norm instead of an exception in distributed systems. Except hardware difficulties, a storage node goes off-line during upgrading and being excluded when the workload is exceptionally high. In either cases, the system should be able to serve the data request without accessing the unavailable nodes.

In this project, we implemented a mini-actual distributed storage system in local operating and file system by implementing low-level coding algorithms. The performance is evaluated and compared across different implementations. The main features of the system include: 

\begin{enumerate}
	\item Storing and access a single file across simulated storage nodes using RAID 6 for fault-tolerance
	
	\item Ability to determine the failure of storage nodes at execution time
	
	\item Ability to rebuild lost redundancy at a replacement storage node
	
	\item Generalized encoding algorithm in extension to the original 6+2 erasure coding
\end{enumerate}


The rest of this paper is organized as follows. We briefly introduce background concepts and technologies that are relevant to the system design and development in Section 2. System architecture and algorithms are covered in Section 3. Experiment setup and results analysis are found in Section 4, followed by conclusion in Section 5.
